lb $2, $0, 0 // 区画数を$2に
lb $3, $0, 1 // 辺の数を$3に
addi $4, $0, 3 // BitMask 0b0011(乱数生成した値を0から4にするため)
add $1, $2, $0 // $1をリセット(reset)
add $1, $2, $1 // $1はループカウンタ。数を減らし、0になったら終了
add $1, $2, $1
add $1, $2, $1 // ここまで4行で区画数*4を$1に。パターン生成は32bit単位で行うため。
addi $1, $1, -4 // ループ先頭(genloop)
rand $5 // $5に乱数生成
and $5, $5, $4 // $5をマスクして0から3のどれかに
sw $5, $1, 1024 // 生成した乱数は1024番地から区画数だけ保存する
bne $1, $0, -5 // ループ先頭(genloop)に戻る
add $1, $3, $0
add $1, $3, $1 // 辺の数の2倍を$1に。2倍なのはそれぞれ2つ数字を持ってるから。
addi $1, $1, -1 // ループ先頭(chkloop)
lb $6, $1, 2 // inputの右側に相当する数字の読み込み
add $6, $6, $6 // アドレスのオフセットを計算するために2倍
add $6, $6, $6 // さらに2倍して最終的に4倍に
addi $1, $1, -1 // カウンタデクリメント
lb $7, $1, 2 // inputの左側に相当する数字の読み込み
add $7, $7, $7 // うえに同じ
add $7, $7, $7
lw $8, $6, 1024 // 該当する辺の色を読み込み
lw $9, $7, 1024
beq $8, $9, -22 // 辺の色が同じだったら誤りパターンなので、resetに戻り再生成
bne $1, $0, -12 // 辺の色が同じで、チェックがまだ最後まで言ってなかったらchkloopに戻る
sw $3, $0, 32767 // ダミーの書き込み(これでシミュレーターが止まる)
beq $0, $0, -1 // 実機用のループ

